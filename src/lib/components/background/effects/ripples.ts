/**
 * ripples.ts
 *
 * This module manages the creation, animation, and drawing of ripple effects
 * on the water surface. Ripples are generated by user interactions (mouse moves, clicks,
 * long presses) or ambiently.
 */
import { RIPPLE_CONFIG } from '../constants';
import { addRipple, getRipples, releaseRipple } from '../animationState';
import type { Ripple, RippleType } from '../types';

/**
 * Creates a new ripple effect based on the specified type and coordinates.
 * Retrieves configuration from `RIPPLE_CONFIG` and may apply slight randomization.
 * Adds the new ripple to the central `animationState`.
 *
 * @param x - The x-coordinate for the ripple's center.
 * @param y - The y-coordinate for the ripple's center.
 * @param type - The type of interaction or event causing the ripple (e.g., 'mouseMove', 'ambient').
 *               This determines the ripple's appearance and behavior from `RIPPLE_CONFIG`.
 * @throws Error if an unknown ripple type is provided.
 */
export function createRipple(x: number, y: number, type: RippleType): void {
	const config = RIPPLE_CONFIG[type];
	if (!config) {
		// Defensive coding: ensure a configuration exists for the given type.
		console.error(`Unknown ripple type: ${type}. Ensure it is defined in RIPPLE_CONFIG.`);
		throw new Error(`Unknown ripple type: ${type}`);
	}

	let rippleSpeed = config.speed;
	let rippleMaxRadius = config.maxRadius;

	// Apply slight randomization to user-initiated ripples for a more natural look.
	if (type === 'mouseMove' || type === 'click') {
		rippleSpeed = config.speed * (0.9 + Math.random() * 0.2);
		rippleMaxRadius = config.maxRadius * (0.9 + Math.random() * 0.2);
	}

	// Add the configured ripple to the animation state.
	addRipple({
		x,
		y,
		radius: 0, // Ripples start with a radius of 0.
		maxRadius: rippleMaxRadius,
		opacity: config.initialOpacity,
		speed: rippleSpeed,
		lineWidth: config.lineWidth,
		color: config.color,
		isAmbient: type === 'ambient',
		decayRate: config.decayRate
	});
	// Note: Maximum ripple count enforcement is handled implicitly by performance or could be
	// explicitly managed in animationState if strict limits are needed.
}

/**
 * Iterates through all active ripples, updates their state (radius, opacity),
 * and draws them onto the canvas. Ripples that have faded or grown too large are released
 * back to the object pool via `animationState.releaseRipple`.
 *
 * @param ctx - The 2D canvas rendering context to draw upon.
 */
export function updateAndDrawRipples(ctx: CanvasRenderingContext2D): void {
	const originalGlobalAlpha = ctx.globalAlpha; // Preserve original alpha for other draw calls.
	const currentRipples: Ripple[] = getRipples(); // Get the current list of active ripples.

	// Iterate backwards to safely remove ripples (via releaseRipple) without affecting the loop index.
	for (let i = currentRipples.length - 1; i >= 0; i--) {
		const r = currentRipples[i];

		// Update ripple state.
		r.radius += r.speed;
		r.opacity -= r.decayRate;

		// Check for removal conditions (fully faded or expanded beyond max size).
		if (r.opacity <= 0 || r.radius >= r.maxRadius) {
			releaseRipple(r); // Return the ripple to the inactive pool.
			continue; // Skip drawing this ripple as it's now inactive.
		}

		// Draw the ripple.
		ctx.beginPath();
		ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
		ctx.lineWidth = r.lineWidth;
		ctx.strokeStyle = r.color;
		ctx.globalAlpha = Math.max(0, r.opacity); // Ensure opacity doesn't go negative.
		ctx.stroke();
	}
	ctx.globalAlpha = originalGlobalAlpha; // Restore the original global alpha.
}
